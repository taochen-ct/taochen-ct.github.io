---
prev:
    text: 'Overview'
    link: '/python'
next:
    text: 'Decorator'
    link: '/python/decorator'
---

# 垃圾回收
<br>

在 Python 中，垃圾回收（GC）机制主要通过 **引用计数**、**分代回收** 和 **标记-清除（Mark-and-Sweep）** 三种方式来管理内存。

### 1. **引用计数（Reference Counting）**

引用计数是 Python 最基本的垃圾回收机制。当一个对象被创建时，系统会为它分配一个引用计数器，用来记录有多少个地方引用该对象。每当一个引用指向该对象时，计数器增加；当一个引用不再指向该对象时，计数器减少。如果计数器为零，说明没有任何地方再引用该对象，Python 就会释放该对象占用的内存。

#### **优点**：

- 简单直接，垃圾回收的延迟较低。
- 对于大多数简单对象来说，效果很好。

#### **缺点**：

- 无法处理循环引用问题，即当两个对象互相引用时，它们的引用计数永远不会为零，即使它们不再被其他地方引用。

---

### 2. **分代回收（Generational Garbage Collection）**

分代回收是 Python 在引用计数的基础上引入的优化机制。对象的生命周期会被划分为不同的 "代"（generations）。Python 将所有对象分为三个代：

- **第0代**（young generation）：新创建的对象。
- **第1代**（middle generation）：经历了一次垃圾回收的对象。
- **第2代**（old generation）：经历了多次垃圾回收的对象。

#### **工作原理**：

- **年轻代对象**通常更容易被垃圾回收，因为它们更有可能被很快丢弃。
- Python 的垃圾回收器会定期检查年轻代的对象，如果它们的引用计数降到 0，回收器会将它们从内存中清除。
- **老年代对象**不太容易被回收，因此它们会在进行垃圾回收时进行更少的检查。

#### **回收过程**：

- **年轻代回收**：如果第 0 代中的对象的数量达到某个阈值，回收器会对第 0 代进行垃圾回收。
- **提升（Promotion）**：如果第 0 代对象长时间存活，它们会被“提升”到第 1 代；如果它们在第 1 代存活足够长，它们会被提升到第 2 代。
- **老年代回收**：如果第 1 代和第 2 代的对象数超过阈值，Python 会进行全堆回收（包括年轻代和老年代），这通常比较消耗资源。

#### **优点**：

- 分代回收能提高垃圾回收的效率，因为对于年轻的对象，它们更可能是短期存在的，容易被回收，而对于存活时间较长的对象，回收频率较低。

#### **缺点**：

- 如果有大量的短期对象存在，可能会导致垃圾回收频繁运行，影响性能。

---

### 3. **标记-清除（Mark-and-Sweep）**

标记-清除是一种常见的垃圾回收算法，Python 的垃圾回收机制也采用了这一方法。这个方法通过标记和清除两个阶段来回收内存。

#### **工作原理**：

- **标记阶段（Mark Phase）**：垃圾回收器从所有活动的对象开始，递归地遍历所有对象并标记它们。如果一个对象可达（有引用指向它），则标记为“活动”对象。
- **清除阶段（Sweep Phase）**：垃圾回收器检查所有对象，如果一个对象未被标记为活动对象，则意味着它是垃圾，可以被清除，释放内存。

#### **优点**：

- 能够有效处理循环引用的问题，这种方式通过扫描整个对象图，标记存活的对象并清除那些不可达的对象。

#### **缺点**：

- 标记和清除阶段的过程可能比较消耗资源，尤其是在需要回收老年代或进行全堆回收时。

---

### **总结**

Python 的垃圾回收机制主要由以下三部分组成：

1. **引用计数**：简单、快速，但不能处理循环引用问题。
2. **分代回收**：通过将对象分为不同代来优化垃圾回收，适用于大部分场景。
3. **标记-清除**：用于处理循环引用，尤其是老年代回收时有效，但可能引起性能开销。

Python 的垃圾回收通常结合了这三种技术，其中引用计数是基础，分代回收和标记-清除则用于优化性能和处理复杂的内存管理问题。