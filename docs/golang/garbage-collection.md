---
title: GC
prev:
   text: 'Overview'
   link: '/golang'
next:
   text: 'New And Make'
   link: '/golang/new-and-make'
---

# 垃圾回收机制 

Go（Golang）的垃圾回收机制（Garbage Collection，简称 GC）是由 **Go Runtime** 提供的，用于自动管理内存，确保内存被有效地分配和回收，而不需要开发者显式地进行内存管理。Go
的垃圾回收机制采用了 **标记-清除** 和 **分代收集** 的结合，并且尽量使其工作效率更高，以减少对并发程序的影响。

### Go 垃圾回收机制的特点

1. **标记-清除算法（Mark-and-Sweep）**

    - Go 使用 **标记-清除**（Mark-and-Sweep）算法来进行垃圾回收。其基本过程包括两个步骤：
        - **标记阶段**：从根对象（通常是栈上的指针、全局变量等）开始，递归遍历所有可达的对象，并将它们标记为存活（可达）。
        - **清除阶段**：遍历整个堆，释放那些没有被标记为存活的对象，即不可达的对象。

   Go GC 会在后台进行标记-清除操作，在这个过程中，运行时会暂停应用程序的执行（称为 **STW**，Stop The World），但这个暂停时间非常短暂，现代
   Go 版本中会努力减少 STW 的时间。

2. **三色标记法（Tri-Color Marking）** Go 的标记-清除算法采用了 **三色标记法**，即使用三种颜色来表示对象的状态：

    - **白色（White）**：表示对象未被标记，可能是垃圾。
    - **灰色（Gray）**：表示对象已被标记，但尚未遍历其引用的对象。
    - **黑色（Black）**：表示对象已经被标记，并且它所引用的所有对象也已经被标记。

   在标记阶段，Go 会将活动对象从白色状态转换为灰色，并逐步遍历灰色对象的引用，最终变为黑色。

3. **并发垃圾回收（Concurrent GC）** Go
   的垃圾回收机制在标记阶段是并发的。标记阶段与应用程序的执行是并行的，因此程序的主线程（goroutine）在垃圾回收时可以继续执行。并发垃圾回收的设计能够显著减少应用程序停顿的时间。

4. **增量式回收** Go 的垃圾回收是 **增量式** 的。也就是说，GC 过程会分阶段进行，每个阶段只回收一部分内存，避免了传统的标记-清除回收中需要长时间停止应用程序的问题。

   Go 的垃圾回收机制利用了 **标记和清除的增量性**，在多个阶段中进行 GC，使得应用程序能够在回收过程中仍然保持较高的吞吐量。

5. **分代回收** Go 的垃圾回收机制并不像一些语言（如 Java）那样明确分为多个代（年轻代、老年代等）。但是，Go
   会根据对象的存活时间来动态调整垃圾回收的策略。即：新分配的对象往往生命周期较短，这些对象会被频繁回收；而存活较久的对象会被回收得相对较少。

6. **实时性与暂停时间（Stop-the-World）** Go GC 设计的一个重要目标是尽量减少应用程序的停顿时间。为了实现这一点，Go 的 GC
   会尽量让垃圾回收过程并发执行，但会有一个 **Stop-the-World**（STW） 阶段。在这个阶段，应用程序的所有 goroutine
   都会暂停，垃圾回收会在这个阶段标记和清除对象。

   Go 通过多种手段减少 STW 的时间，比如使用 **增量式** 和 **并发标记**，使得 STW 的时间尽可能短。

---

### **Go 垃圾回收的过程**

1. **开始垃圾回收**：

    - 在堆中分配的对象数量达到一定阈值时，Go 会启动垃圾回收。
2. **标记阶段**（并发）：

    - 从根对象开始，递归标记所有可达对象。这个阶段是并发的，应用程序可以继续运行，只是会有部分 goroutine 在垃圾回收时暂停。
3. **清除阶段**：

    - 在标记阶段完成后，Go 会开始清除所有不可达的对象，即没有被标记为可达的对象。这一阶段的清除是并发执行的。
4. **GC 完成**：

    - 垃圾回收完成后，系统会继续执行应用程序，回收的内存会被释放。

---

### **Go GC 的调优与性能**

1. **GC 参数**：

    - `GOGC`：Go 的垃圾回收有一个环境变量 `GOGC`，它控制垃圾回收的频率。默认值是 100，意味着垃圾回收会在堆的大小增长 100%
      后触发。如果你将 `GOGC` 设置为较低的值，垃圾回收会更频繁；如果设置较高，GC 会较少触发，性能会提升，但内存消耗也会更大。
        - 例如：`export GOGC=200` 会使垃圾回收触发的时间延迟到堆大小增长 200% 后。
2. **GC 停顿时间**：

    - 由于 Go 的垃圾回收是并发的，STW（Stop-the-World）时间已经被优化到非常低。Go GC 设计上力求在保证低延迟的同时高效地进行垃圾回收。
3. **垃圾回收调试**：

    - `runtime.GC()`：显式调用垃圾回收。
    - `GODEBUG=gctrace=1`：启用 GC 调试，可以查看垃圾回收的日志。
    - `runtime.ReadMemStats()`：可以查看内存使用情况，了解当前的垃圾回收状况。

---

### **总结**

Go 的垃圾回收机制设计目标是高效、低延迟、并发，并且减少对程序性能的影响。它通过 **标记-清除算法**、**并发标记**、**增量式回收
** 和 **最小化 STW 时间**，实现了高效的内存管理。对于大部分应用，Go 的默认垃圾回收机制已经能够满足需求，但开发者可以通过调节
GC 参数来优化性能，尤其是在对延迟要求较高的场景下。

### 与Python GC机制对比

| 特性           | **Python**           | **Go**                   |
|--------------|----------------------|--------------------------|
| **垃圾回收算法**   | 引用计数 + 分代回收 + 标记-清除  | 标记-清除（Mark-and-Sweep）    |
| **是否处理循环引用** | 需要通过标记-清除处理          | 通过标记-清除处理                |
| **GC 暂停时间**  | 可能较长，尤其是涉及标记-清除时     | 尽量减少，但仍然可能存在较长的暂停        |
| **内存碎片**     | 可能存在，尤其是大量小对象时       | 可能存在，但相对较少               |
| **调优**       | 可以调整 GC 设置，但无法精细控制   | 可以调整 `GOGC` 环境变量，但分代机制较弱 |
| **并发性**      | GC 会阻塞应用程序执行         | GC 在标记阶段是并发的，减少了停顿       |
| **GC 开销**    | 高于 Go，特别是在频繁的对象创建销毁时 | 较低，但会在内存紧张时增加开销          |

- **Python 的 GC 机制** 在小型应用和较为简单的内存管理场景下表现较好，但在面对大规模对象和复杂内存结构时，垃圾回收的停顿和性能开销可能成为瓶颈。尤其是在循环引用较多的情况下，标记-清除回收机制显得尤为重要。

- **Go 的 GC 机制** 在并发程序中更加适合，标记-清除算法的并发性减少了停顿时间，但并发回收和增量回收带来的一些开销和复杂性可能会影响性能，尤其在内存压力较大时。

