---
title: redis
---

# Redis快的原因

## 纯内存操作

Redis所有数据操作均在内存中完成，避免传统磁盘数据库的I/O瓶颈。内存操作速度可达纳秒级，相比磁盘访问(毫秒级)提升5个数量级，奠定性能基础‌ 。

## 高性能数据结构

内置优化数据结构：字符串、跳跃表、压缩列表、哈希表等针对不同场景设计（如压缩列表减少短数据内存占用，跳跃表实现快速范围查询）

Redis内置的8种数据结构经过精细优化：

- 哈希表采用 双表 渐进式rehash，平均时间复杂度保持O(1)
- 压缩列表（ziplist）和整数集合（intset）将小数据存储密度提升3-5倍
- 跳跃表（skiplist）在有序集合操作中，提供平均O(log n)的查询性能，**空间  开销**  比平衡树低40%

## 单线程 无锁架构

Redis采用单线程模型处理所有客户端请求，消除了多线程环境下的上下文切换开销（每次切换约需微秒级）和锁竞争。

- 单线程模型避免多线程上下文切换（每次切换约1μs）和锁竞争开销
- 原子性操作天然避免并发安全问题，指令执行无阻塞
- CPU缓存命中率更高（L1缓存访问仅0.5ns）

## 事件驱动 + IO多路复用

通过epoll/kqueue等IO多路复用技术，Redis实现了单线程同时处理数万个客户端连接。这种机制将网络事件（读、写、连接）转化为非阻塞事件，CPU利用率高达95%。

- Reactor模式实现单线程处理20万+连接
- epoll/kqueue系统调用实现μs级事件触发，对比传统阻塞IO模型吞吐量提升100倍
- 网络包解析与命令执行流水线化，事件分派延迟<1ms‌

## 异步日志

Redis的RDB和AOF进行异步持久化，并且优化了策略。提供了灵活的性能-可靠性权衡：

- 持久化采用RDB快照（fork子进程写入）与AOF日志（后台线程fsync）分离
- 日志写入延迟从同步模式的10ms级降低至异步模式100μs级
- 写操作缓冲区实现批量刷盘，吞吐量提升5-10倍‌
- RDB每秒级快照，恢复速度达100MB/s
- AOF追加写入支持fsync可配置，每秒持久化模式下性能损耗<5% , 主从同步带宽占用<10%，实现了高性能与可靠性的完美平衡。