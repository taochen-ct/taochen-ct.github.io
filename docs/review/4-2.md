---
title: "04-02"
---

# 知识点

## SQL 优化实践和思考点
- 索引优化：创建合理的索引（如覆盖索引、前缀索引），避免全表扫描。
- 查询优化：使用 EXPLAIN 分析执行计划，避免 SELECT *，优化 JOIN。
- 分库分表：对大表进行水平或垂直拆分，提高查询效率。
- 缓存：利用 Redis、Memcached 缓存热点数据，减少数据库压力。
- 连接池：使用数据库连接池，如 HikariCP，提高并发性能。

## 事务实现原理
事务（Transaction）基于 ACID（原子性、一致性、隔离性、持久性）：

- 原子性（Atomicity）：通过 Undo Log 记录回滚信息。
- 一致性（Consistency）：事务前后数据库状态保持一致。
- 隔离性（Isolation）：通过 MVCC（多版本并发控制）或锁机制隔离不同事务。
- 持久性（Durability）：依靠 Redo Log 确保事务提交后不会丢失。

## Redo Log 工作机制
**作用：** 保证事务的持久性（D in ACID）。

**写入方式：**
  1. 事务执行时，先写入 Redo Log（WAL 机制）。
  2. Redo Log 写入磁盘后，事务才算提交（避免宕机丢失）。
  3. 后续通过 Checkpoint 机制将数据刷入数据页（数据最终落盘）。

## 协程数量如何确定
- I/O 密集型任务：可以开大量协程（取决于数据库连接数、网络 I/O）。
- CPU 密集型任务：协程数量 ≈ CPU 核心数，避免 CPU 过度切换。
- 内存限制：协程栈通常较小（如 Golang 默认 2KB），但过多仍可能导致 OOM。

## CPU 密集型任务使用协程是否有效
- 协程本质是用户态线程，适合 I/O 密集型任务。
- CPU 密集型任务需要占用 CPU，使用协程无法减少计算量。
- 解决方案：
  1. 使用 runtime.GOMAXPROCS 充分利用多核 CPU（Go）。
  2. 采用多进程并行计算（Python/Rust）。

## 协程是跨线程的吗
- Go：Goroutine 由调度器 GPM 机制分配，可以跨线程执行。
- Python asyncio：协程运行在单线程内，不跨线程。
- Rust tokio：协程可调度到不同线程执行。

## 多线程执行协程会引入资源竞争问题吗
是的，如果协程访问共享资源（如全局变量、数据库连接），可能导致竞争。

**解决方案：**
- 锁（Mutex、读写锁）。
- Channel 进行线程间通信（如 Go chan、Rust mpsc）。
- 事务隔离 避免数据库竞态。

## 本地缓存和 Redis 一致性保证
**缓存更新策略：**
- 写后更新：数据变更时，更新 Redis 缓存。
- 失效策略：删除缓存，等待下一次查询自动加载。
- 双写不一致：可使用消息队列（Kafka）异步更新 Redis。

## 多机本地缓存一致性方案
- 基于消息队列：数据变更时广播更新。
- 基于分布式一致性协议（如 etcd、Zookeeper）。
- Redis 作为缓存协调中心，所有实例查询 Redis 共享缓存。

## Redis 高性能原理
- 单线程模型（避免上下文切换）。
- 高效数据结构（如 ZipList、SkipList）。
- 持久化方式优化（AOF/快照）。
- Pipeline 批量处理（减少 RTT）。

## Redis 多线程 vs 单线程争议
- Redis 6.0 引入多线程（用于 I/O 处理）。
- 数据操作仍是单线程（避免锁竞争）。
- 适用于 大 key 删除、慢查询优化。

## BitMap 做用户签到的劣势
- 只能记录是否签到，无法存储其他信息。
- 不可扩展性：固定长度（按天数预分配）。
- 查询不灵活：不支持复杂查询，如时间段统计。

## Redis 集群持久化和备份机制
- RDB（快照）：定期保存整个数据集。
- AOF（日志）：记录每次写操作，支持重放。
- 主从复制：数据多机备份，防止单点故障。

## Key 分片策略
- Hash 分片（如一致性哈希）。
- Range 分片（按 key 前缀分库）。
- 哈希槽分片（Redis Cluster 采用 16384 个槽）。

## Redis 集群槽位数量设计
- 固定 16384 槽，基于 CRC16 取模分配到不同节点。
- 节点扩容/缩容时，槽会重新分配。

## C++ 多态实现原理
- 通过 虚函数表（vtable） 实现。
- 每个对象持有 虚表指针（vptr） 指向类的 vtable。

## C++ 编译生成可执行文件过程
- 预处理：宏展开、头文件展开。
- 编译：生成 .o 目标文件。
- 汇编：转换为机器码。
- 链接：合并库、符号解析，生成可执行文件。

## 多进程/多线程适用场景
- 多进程：进程间隔离（如 Web 服务器）。
- 多线程：共享内存（如数据库连接池）。

## Nginx 采用多进程还是多线程
- 多进程模型，防止单个进程崩溃影响整体。

## 高性能网关设计方案
- 异步非阻塞（如 Nginx、Envoy）。
- 负载均衡（LVS、Consistent Hash）。
- 缓存优化（CDN、Redis）。

## 进程间通信最快方式
- 共享内存（shm）最快，避免数据拷贝。

## HTTPS 改进与性能代价
- 改进：TLS1.3 减少握手时间。
- 代价：加密/解密耗费 CPU。

## 常用 Linux 命令
- `top`、`ps`、`lsof`、`df`、`netstat`。

## 高 CPU 进程定位
- `top` → `ps -eo pid,comm,%cpu --sort=-%cpu`。

## PID 生成机制
- 按序递增，超过上限回绕。

## 查找目录下最大的 10 个文件
```python
du -ah | sort -rh | head -10
```
